== Errors and failing with grace

I've yet to meet a programmer who can write lines and lines and lines of code without ever getting an error. Python wants us to be super precise. If we forget a colon or a parentheses, Python will simply refuse to do anything until we go and fix our mistake. In this lesson, we're going to learn about what errors in Python look like, how to read the errors, and 

=== What you'll need to know...

We won't be using `if` statements in this lesson, but we'll be learning about something that looks very similar. Be comfortable with writing `if / else` statements before you move on.

=== A note for the mentor

Errors freak students out at first. Some will think they've broken Python. Others will take it as a sign that they should never write another line of code. I've watched students walk away from a program that was mostly working because tracebacks can look scary at first blush.

It's important to emphasize that everyone gets errors. The only difference between the errors a beginner gets and the errors an experienced coder gets is that the experienced coder gets more obtuse errors. Well, sometimes. Over a decade in, I still forget colons now and then.

We're also going to be learning about catching exceptions with `try / except`. It's vital that you emphasize that you need to be careful about catching errors. Some students will start wrapping all of their code in a `try / except` so that they never have to see an error again!

=== What does an error look like?

You've probably seen an error already, but just in case your Python has been 100% perfect, let's go ahead and make Python throw an error. Run the following code, and watch what Python spits out.

[source,python]
----
x = 1 / 0
----

You should have gotten something like this:

[source,python]
----
>>> x = 1 / 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
----

When Python throws an error (and yes, we call it _throwing_ an error), we call it a *traceback*. Python starts at where it got an error, and steps back in the program to show where it was right before the error happened.

Think of it like this: Have you ever misplaced something? Someone will usually ask you where you were the last time you had it. When you tell them, they ask you where you were before that, and before that, and before that. You retrace your steps until you find the thing you lost. Python is doing the same thing, telling you where your code went off the rails, and then talking about everything it was doing up until that point.

=== Errors are good!

Errors can seem really scary at first! Python spits a bunch of information at you and your code isn't working and it can be tempting to just walk away and become a hermit. 

As an experienced developer, however, I feel relieved when I see an error. Python is doing its very best to tell me how to make my program work. I have something I can pop into a search engine, which allows me to find out how other people solved my problem. I have something I can easily share with my friends, so they can help me figure out what's going on.

Sometimes, programs don't work the way you expect them to, but they don't give you an error. That is _much_ harder to figure out. You have to start digging through your code to sort out where things have gone wrong, which takes much longer.

=== Figuring out a traceback

There are two parts to a traceback: 

* What Python was doing
* What kind of error you got

Here, I have a script that threw an error:

----
Name: Jacob
Age: 13
Traceback (most recent call last):
  File "makeerror.py", line 18, in <module>
    main()
  File "makeerror.py", line 15, in main
    print_stuff(name, age)    
  File "makeerror.py", line 10, in print_stuff
    print "Hi, " + name + ", who is " + age + "."
TypeError: cannot concatenate 'str' and 'int' objects
----

In general, I scroll down to the bottom of my traceback and read up. The last part of the traceback is the exact error I got:

----
TypeError: cannot concatenate 'str' and 'int' objects
-----

The first word is the kind of error, and the rest of the text tries to explain exactly what happened. Apparently, we can't "concatenate" some things?

If I look up "concatenate" in any dictionary, I see that means "add together." Okay, we tried to add two things together that can't be added. Python says I tried to add "str" and "int" together... Sounds like I tried to add a string and an integer together, doesn't it?

If we look a the next two lines up (remember, we're starting from the bottom), we can see a bit of code, and where it is in my script:

----
  File "makeerror.py", line 10, in print_stuff
    print "Hi, " + name + ", who is " + age + "."
----

It looks like the script is trying to print out something using a plus sign. It's a good bet that age is an integer! This is probably where our error is from, but if we weren't sure, we could keep going back. At least now, we have a place to start digging around.

=== Some common types of errors

It's good to be familiar with some of the basic errors that you can get in Python. Sure, you can look them up when you get them, but if you can skip a search, then you can get to solving your problem even faster!

*SyntaxError*: Syntax is the grammar of a programming language. Python expects certain everything in a certain order, and is very particular about you remembering to put colons and parentheses where they need to be. 

For example, here, I forgot to add the colon when making an `if` statement:

[source,python]
----
>>> if 1 == 1
  File "<stdin>", line 1
    if 1 == 1
            ^
SyntaxError: invalid syntax
----

If you get this, double check what sort of syntax Python is expecting. 

*IndentationError*: You probably have gotten this one a few times. Python needs you to indent your code properly, so it knows what goes in a block. Here, I didn't indent my code properly, causing Python to throw an error:

[source,python]
----
>>> while True:
print "Hey"
  File "<stdin>", line 2
    print "Hey"
        ^
IndentationError: expected an indented block
----

If you see this, make sure that all of the code in a block is indented the same number of spaces.

*NameError*: Often, this error will pop up if you try to use a variable that doesn't exist yet. Nine times out of ten, when I see this, it's because I made a typo somewhere. In this example, pay attention to what variables I'm using:

[source,python]
----
>>> myname = "Katie"
>>> print mynmae
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'mynmae' is not defined
----

If you see this, check to see that the variable that threw the error is spelled correctly, and that you've used it at least once.

*TypeError*: All data has types, and we can only do specific things with certain types of data. If you see this pop up, then you're probably trying to do something with that type of data that you can't do. For example, I can't add a list to an integer.

[source,python]
----
>>> [1, 2, 3] + 4
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only concatenate list (not "int") to list
----

If you see this, either use a different way of doing what you want to do, or convert the value that's giving you trouble into a data type that works.

*IndexError*: You usually see this error with lists. It pops up when you a list doesn't have anything for an index that you give it. For example, this list only goes up to index two, and we're trying to see what's in index three.

[source,python]
----
>>> mylist = [1, 2, 3]
>>> mylist[3]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
----

If you see this, double check how many items you actually have in your list first by using `len()`.

*KeyError*: This error is like an IndexError for dictionaries. When you see this, it's probably because the dictionary you're working with doesn't have a value paired with the key you're trying to use. Here, I have the keys "one", "two", and "three", but not "four":

[source,python]
----
>>> mydict = {"one": 1, "two": 2, "three": 3}
>>> mydict["four"]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'four'
----

If you see this, you might want to add an `if` statement, checking to see if that key is actually in that dictionary.

=== Sharing a traceback

=== Working around errors

==== No naked exceptions!

=== Forcing an error

=== Try this!

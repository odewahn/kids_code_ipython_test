== Errors and failing with grace

I've yet to meet a programmer who can write lines and lines and lines of code without ever getting an error. Python wants us to be super precise. If we forget a colon or a parentheses, Python will simply refuse to do anything until we go and fix our mistake. In this lesson, we're going to learn about what errors in Python look like, how to read the errors, and 

=== What you'll need to know...

We won't be using `if` statements in this lesson, but we'll be learning about something that looks very similar. Be comfortable with writing `if / else` statements before you move on.

=== A note for the mentor

Errors freak students out at first. Some will think they've broken Python. Others will take it as a sign that they should never write another line of code. I've watched students walk away from a program that was mostly working because tracebacks can look scary at first blush.

It's important to emphasize that everyone gets errors. The only difference between the errors a beginner gets and the errors an experienced coder gets is that the experienced coder gets more obtuse errors. Well, sometimes. Over a decade in, I still forget colons now and then.

We're also going to be learning about catching exceptions with `try / except`. It's vital that you emphasize that you need to be careful about catching errors. Some students will start wrapping all of their code in a `try / except` so that they never have to see an error again!

=== What does an error look like?

You've probably seen an error already, but just in case your Python has been 100% perfect, let's go ahead and make Python throw an error. Run the following code, and watch what Python spits out.

[source,python]
----
x = 1 / 0
----

You should have gotten something like this:

[source,python]
----
>>> x = 1 / 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
----

When Python throws an error (and yes, we call it _throwing_ an error), we call it a *traceback*. Python starts at where it got an error, and steps back in the program to show where it was right before the error happened.

Think of it like this: Have you ever misplaced something? Someone will usually ask you where you were the last time you had it. When you tell them, they ask you where you were before that, and before that, and before that. You retrace your steps until you find the thing you lost. Python is doing the same thing, telling you where your code went off the rails, and then talking about everything it was doing up until that point.

=== Errors are good!

Errors can seem really scary at first! Python spits a bunch of information at you and your code isn't working and it can be tempting to just walk away and become a hermit. 

As an experienced developer, however, I feel relieved when I see an error. Python is doing its very best to tell me how to make my program work. I have something I can pop into a search engine, which allows me to find out how other people solved my problem. I have something I can easily share with my friends, so they can help me figure out what's going on.

Sometimes, programs don't work the way you expect them to, but they don't give you an error. That is _much_ harder to figure out. You have to start digging through your code to sort out where things have gone wrong, which takes much longer.

=== Figuring out a traceback

There are two parts to a traceback: 

* What Python was doing
* What kind of error you got

Here, I have a script that threw an error:

----
Name: Jacob
Age: 13
Traceback (most recent call last):
  File "makeerror.py", line 18, in <module>
    main()
  File "makeerror.py", line 15, in main
    print_stuff(name, age)    
  File "makeerror.py", line 10, in print_stuff
    print "Hi, " + name + ", who is " + age + "."
TypeError: cannot concatenate 'str' and 'int' objects
----

In general, I scroll down to the bottom of my traceback and read up. The last part of the traceback is the exact error I got:

----
TypeError: cannot concatenate 'str' and 'int' objects
-----

The first word is the kind of error, and the rest of the text tries to explain exactly what happened. Apparently, we can't "concatenate" some things?

If I look up "concatenate" in any dictionary, I see that means "add together." Okay, we tried to add two things together that can't be added. Python says I tried to add "str" and "int" together... Sounds like I tried to add a string and an integer together, doesn't it?

If we look a the next two lines up (remember, we're starting from the bottom), we can see a bit of code, and where it is in my script:

----
  File "makeerror.py", line 10, in print_stuff
    print "Hi, " + name + ", who is " + age + "."
----

It looks like the script is trying to print out something using a plus sign. It's a good bet that age is an integer! This is probably where our error is from, but if we weren't sure, we could keep going back. At least now, we have a place to start digging around.

==== Some common types of errors

It's good to be familiar with some of the basic errors that you can get in Python. Sure, you can look them up when you get them, but if you can skip a search, then you can get to solving your problem even faster!

*SyntaxError*: Syntax is the grammar of a programming language. Python expects certain everything in a certain order, and is very particular about you remembering to put colons and parentheses where they need to be. 

For example, here, I forgot to add the colon when making an `if` statement:

[source,python]
----
>>> if 1 == 1
  File "<stdin>", line 1
    if 1 == 1
            ^
SyntaxError: invalid syntax
----

If you get this, double check what sort of syntax Python is expecting. 

*IndentationError*: You probably have gotten this one a few times. Python needs you to indent your code properly, so it knows what goes in a block. Here, I didn't indent my code properly, causing Python to throw an error:

[source,python]
----
>>> while True:
print "Hey"
  File "<stdin>", line 2
    print "Hey"
        ^
IndentationError: expected an indented block
----

If you see this, make sure that all of the code in a block is indented the same number of spaces.

*NameError*: Often, this error will pop up if you try to use a variable that doesn't exist yet. Nine times out of ten, when I see this, it's because I made a typo somewhere. In this example, pay attention to what variables I'm using:

[source,python]
----
>>> myname = "Katie"
>>> print mynmae
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'mynmae' is not defined
----

If you see this, check to see that the variable that threw the error is spelled correctly, and that you've used it at least once.

*TypeError*: All data has types, and we can only do specific things with certain types of data. If you see this pop up, then you're probably trying to do something with that type of data that you can't do. For example, I can't add a list to an integer.

[source,python]
----
>>> [1, 2, 3] + 4
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only concatenate list (not "int") to list
----

If you see this, either use a different way of doing what you want to do, or convert the value that's giving you trouble into a data type that works.

*IndexError*: You usually see this error with lists. It pops up when you a list doesn't have anything for an index that you give it. For example, this list only goes up to index two, and we're trying to see what's in index three.

[source,python]
----
>>> mylist = [1, 2, 3]
>>> mylist[3]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
----

If you see this, double check how many items you actually have in your list first by using `len()`.

*KeyError*: This error is like an IndexError for dictionaries. When you see this, it's probably because the dictionary you're working with doesn't have a value paired with the key you're trying to use. Here, I have the keys "one", "two", and "three", but not "four":

[source,python]
----
>>> mydict = {"one": 1, "two": 2, "three": 3}
>>> mydict["four"]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'four'
----

If you see this, you might want to add an `if` statement, checking to see if that key is actually in that dictionary.

==== Sharing a traceback

Sometimes, you'll want a second pair of eyes to look at your error. Your first instinct might be to copy the entire error and email it to someone, or paste it in a chat window.

*Don't do this!*

A better way to share errors is to use a website that allows you to share bits of code with other people. You can paste the code into a form, and the website will create a URL for you to share. The formatting will be nicer, you can share the link with many people, and you won't be making someone's chat cliet go nuts.

There are many sites that allow you to share code, but my favorite is dpaste.com. It's simple and free, and you don't need to create an account to use it. Also, it automatically deletes your code after a while, so you don't have to worry about old errors sitting out there forever.

One warning: If there's any sensitive information (like usernames, passwords, etc) in your code, *delete them* before pasting it. Remember, anyone can see these!

=== Working around errors

Sometimes, you know that an error might happen with your code. You don't want Python to stop working, though. Maybe you have a backup plan, or maybe you just want to have the program close without a nasty error.

This is where `try / except` is useful. A `try / except` statement looks a bit like `if \ else`.

[source,python]
----
try:
  code
  code
except ErrorType:
  code
  code
----

When Python sees a `try / except` statement, it will first run all the code in the `try` block. If Python gets an error, it will check to see if there's an `except` block for that error. If there is, Python will run that code and continue with the program. If there isn't a matching `except` block, Python will go ahead and throw the error.

Let's watch this in action! Let's say I want to get two numbers from a user, then divide the first number by the second number:

[source,python]
----
num1 = input("First number: ")
num2 = input("Second number: ")
print "Result:", num1 / num2
----

This works fine... until the user gives me a zero. That causes an error, because you can't divide by zero.

----
First number: 5
Second number: 0
Result:
Traceback (most recent call last):
  File "divzero.py", line 3, in <module>
    print "Result:", num1 / num2
ZeroDivisionError: integer division or modulo by zero
----

We can use `try / except` to work around this possibility, though! Here, we're going to put it around the print statement. If we get a `ZeroDivisionError`, we print "Infinity".

----
num1 = input("First number: ")
num2 = input("Second number: ")
try:
  print "Result:", num1 / num2
except ZeroDivisionError:
  print "Result: Infinity"
----

Now, when we run our program, it doesn't crash when the user gives us a zero.

----
First number: 5
Second number: 0
Result: Result: Infinity
----

Note that our program isn't set up to catch any errors _besides_ dividing by zero. Enter something that isn't a number, and the program will still crash.

==== No naked exceptions!

Every now and then, you'll see something like this:

[source,python]
----
try:
  code
except:
  code
----

Did you see what was missing? The error type! If Python throws _any_ kind of error, the code in the `except` block will run.

At first, this seems like a great time saver. Why figure out what errors you want to prepare for when you can just do one thing for them all? This can make your program act weird, though, and much harder to debug. Remember: *errors are good*. They make it easier for us to figure out how to fix broken code.

So don't let your exceptions be naked!

=== Try this!

In our To-Do list project, we assumed that the file "mytodo.txt" already existed. Add a `try / except` where, if we can't open the file, we create a blank list for our to-do items.

Another place where you might get an error is when the user tries to delete something. Make it so that the user can't give you a bad value. You might use a `while` loop to do this, or a `try / except` statement, or a combination of the two!

== Using modules

One of my main jobs as a programmer is to figure out how to write less code. 

If someone else has done something similar, then it only makes sense to use their code rather than duplicate all of their effort. In the Python community, we often will put up code that helped us in our job for others to use. Most of the time, we don't even charge for it! 

Python comes with a large library of code that other people have written, just to make your life a bit easier. It's well worth the time and energy to get to know what's in this library so that you can start making awesome things sooner.

=== What you'll need to know...

=== A note for the mentor

In this lesson, we're going to *finally* get to modules. 

This is one of the lessons that I find to be the easiest to teach. Students do not mind being shown a shortcut. This is also one of those places where their programs really start to bloom. Feel free to show off your favorite modules, or take an hour to search for modules to help them do what they want to do. If you want more of a guided tour, check out the modules and frameworks appendix.

So buckle up! This should be a fun ride!

=== What's a module?

A module is nothing more than a file that has a bunch of code that you want to import into your code. Once you import a module, you can use everything in it just like you had written the code yourself.

Importing a module usually looks like one of these lines:

[source,python]
----
import module
from module import thing
----

Why import three different ways? Because sometimes you want just a few things, and sometimes you want it all.

If you do `import module`, then Python will import all the things in that module into your program. It might be five things. It might be twenty things. You'll be getting them all, though.

If you use this method, then your code would look something like this:

[source,python]
----
import module

module.thing()
----

If you just want to bring in one thing, then you can do `from module import thing`. Then, your code would look something like this:

[source,python]
----
from module import thing

thing()
----

Notice how we didn't have to say `module.thing()`? We can just use `thing` on its own.

=== Why use them?

The most important reason to use them is that it saves you time. At least, that's the first reason _I_ use modules. I don't want to spend weeks trying to write code that someone else has written! Many of these modules took a long time to write, as well as a crazy amount of expertise.

That brings us to another reason to use modules: Usually, experts wrote them. It's harder than you think to create random numbers, or get Python to spit out a web page. The people who wrote these modules are usually experts in these fields, and the code gets reviewed by other experts.

Another good reason to use modules: They're maintained. Over time, other people in the community will improve the modules so that they run faster, or they fix security issues. Even if you think you might be able to build your own module, you're probably better off using something that everyone wants to keep running.

Finally, they make your code so much easier to maintain. If you need to share your code with someone else, it's likely that they're going to be pretty familiar with how `random()` works. If they don't know, they can just do an Internet search! Can you say as much for your code?

If you think you'll never share your code with anyone else, remember one thing: Future You is a person, too. Chances are good that you'll come back to your code one day, either to change how it works, or remember how you did a cool thing. Be kind to Future You, and write code that's easy to maintain.

Now that you know why you should use modules, let's learn about a few!

=== Random

If you want to make games, chances are, you're going to need get something random at some point. You might want to get a figure out how much damage a monster does, or pick a random piece of treasure, or simply arrange a board in a random manner.

[[random_in_dungeon]]
.It wouldn't be much of a dungeon if nothing random happened.
image::images/randomindungeon.png["A heroine gets bit by a dragon, finds a treasure, and looks at a number puzzle."]

This is where the `random` module comes in. Getting random numbers is strangely hard. Lots of math and tricks go into just picking a random number from one to ten. It's not like your computer can just roll a die! This makes `random` a great example of something you wouldn't want to code yourself, but that can be extremely useful.

==== Getting random numbers

One of the most basic things you can do with `random` is get a random number. `random()` will give you a float between zero and one:

[source,python]
----
>>> from random import random
>>> random()
0.5273507151845394
>>> random()
0.47881243230537496
>>> random()
0.9711759468551575
----

That can sometimes be useful, but usually, I want a number, usually an integer, between two numbers. So, I might want to simulate the roll of a die by getting a number between one and six, or I might decide that a monster can do an amount of damage somewhere between ten and fifteen.

To get a random integer, you use `randint()`. `randint()` expects at least two integers. It then returns an integer between those two values.

[source,python]
----
>>> from random import randint
>>> randint(1, 5)
1
>>> randint(1, 5)
3
>>> randint(1, 5)
4
>>> randint(1, 5)
2
----

How random is `randint()`? Let's find out! Here, we have a quick script. I get 1000 random numbers, and store how many times each one comes up in a dictionary. Then, I print out the dictionary. 

[source,python]
----
from random import randint

totals = {}

for i in range(1000):
  n = randint(1, 10)
  if n in totals:
    totals[n] += 1
  else:
    totals[n] = 1

for num in totals:
  print "{num}:\t{total}".format(num=num, total=totals[num])
----

Run the code and see what you get. The first time I ran it, I got this:

----
1:	101
2:	98
3:	101
4:	101
5:	113
6:	88
7:	96
8:	110
9:	101
10:	91
----

Your numbers will be slightly different, but you should see that each number got used, though some will be used much more and much less. (If one of your numbers was never used, you should probably go play the lottery. The chances of that get pretty close to none!)

==== `random` and lists

Another one of my favorite things to use in the `random` module is `choice()`. `choice()` accepts a list and returns a random item from that list. Here, I have a list of things on my desk. I use `choice()` to pick one out.

[source,python]
----
>>> from random import choice
>>> mystuff = ["phone", "coffee cup", "lamp", "notebook", "chocolates"]
>>> choice(mystuff)
'coffee cup'
>>> choice(mystuff)
'notebook'
>>> choice(mystuff)
'notebook'
----

`random` also comes with a function called `shuffle()`. If you give `shuffle()` a list, Python will mix up all the items in the list. It's like shuffling a deck of cards.

[source,python]
----
>>> from random import shuffle
>>> nums = [1, 2, 3, 4, 5]
>>> shuffle(nums)
>>> print nums
[2, 5, 1, 3, 4]
----

In my code samples, I just imported the function I needed. If I wanted to import the entire `random` module, my code would have looked like this:

[source, python]
----
>>> import random
>>> nums = [1, 2, 3, 4, 5]
>>> random.random()
0.11253931059851596
>>> random.randint(1, 5)
2
>>> random.shuffle(nums)
>>> random.choice(nums)
1
----

Which style you use is up to you. I prefer just importing what I need, but there are times when you might want to just import everything and be done with it.

=== Dates and time

You might think dealing with dates and times would be easy. You do this all the time, after all! If I ask you what time it will be an hour from now, you can probably answer me without thinking too hard.

Dates and times are deceptive, though. It can be easy to forget that things like leap years happen. Figuring out what day of the week a day falls on can be tricky. It's easy to forget that, when dealing with minutes and seconds, you don't count up to 100, but rather stop at sixty.

Python has a library called `datetime` that makes it much easier to deal with dates and time. This is one of those libraries I encourage everyone to take the time to learn, because it's only a matter of time (Ha!) before you need to add it to one of your programs.

==== Getting the current time

The first thing people normally need to use `datetime` for is to get the current time. To do this, we use `now()`.

[source,python]
----
>>> from datetime import datetime
>>> datetime.now()
datetime.datetime(2014, 4, 26, 9, 11, 47, 577735)
----

Take a look at what comes back. It has a bunch of numbers that, at first blush, may not make any sense. They're in a specific order, though. The first one is a year, the second is a month, the third is a date, and so on, down to microseconds (just in case you really need to know what time it is).

----
2014,   4,       26,    9,     11,     47,   577735
^year   ^month   ^day   ^hour  ^min    ^sec  ^microsecond
----

So, when I ran the above code, it was April 26th, 2014, at 9:11 in the morning.

If you want, you can save that value into a variable. That also makes getting the values out of it easier. All you have to do is add what value you want out of the time object to the end of the variable. Here, I'm going to see what hour and year it was when I saved `datetime.now()` to `mytime`.

----
>>> from datetime import datetime
>>> mytime = datetime.now()
>>> mytime.hour
9
>>> mytime.year
2014
>>> mytime.weekday
2
----

The last value I asked the datetime object about was something called "weekday." That's for getting the day of the week. But it returned a two! That's because `weekday`, rather than returning "Monday" or "Sunday", gives us a number that goes with a day of the week. In Python, the week starts at Monday (and Python starts counting at zero), so "2" is "Wednesday."

<<datetime_attr>> has all most of the values you can get out of a datetime object.

[[datetime_attr]]
.Values we can get from a datetime object
[width="50%",options="header"]
|===========================
|Value        |Example
|Year         |d.year
|Month        |d.month
|Day          |d.day
|Minute       |d.minute
|Second       |d.second
|Millisecond  |d.millisecond
|Weekday      |d.weekday
|===========================

==== Creating a date

Sometimes, you want to create a date. For example, you might want to save someone's birthday, or you might want to figure out what day of the week a test falls on. 

Creating a date is easy. You just tell `datetime()` what month, day, and year you want for your date.

[source,python]
----
>>> from datetime import datetime
>>> april_fools = datetime(month=4, day=1, year=2014)
>>> april_fools
datetime.datetime(2014, 4, 1, 0, 0)
----

If you don't give `datetime()` an hour and minute, it assumes that you want to use midnight (so, hour zero and minute zero). If you do want to add a time, you have use 24 hour time. Midnight is hour zero, noon is hour twelve, one o'clock pm is hour thirteen, and all the way up to hour 23. So, let's say I want make a date for lunchtime on July 5, 2014. It would look like this:

[source,python]
----
>>> from datetime import datetime
>>> lunch = datetime(month=7, day=5, year=2014, hour=12, minute=30)
>>> lunch
datetime.datetime(2014, 7, 5, 12, 30)
----

==== Try this!

What day of the week were you born? Start by creating a datetime object with your birthday, then seeing what day of the week it gives you. What day of the week will your birthday be on this year?

=== Turtles!

Turtles are a fun way to play with Python in a visual way! So far, all of what we've been doing has been in the shell or on the command line. The turtle module gives you a super simple way to create patterns and graphics in Python. 

==== Creating a turtle

To create a turtle, you need to import the module `turtle`, then call `showturtle()`.

[source,python]
----
>>> import turtle
>>> turtle.showturtle()
----

Once you run this, you should get a screen that has a small triangle on it, pointing to the right side of the screen.

[[turtlestart]]
.What our turtle looks like when we start it up
image::images/turtlestart.png["A screen with a small triangle on it."]

If you go back to your shell, you can start entering commands that allow you to control your turtle!

==== Moving it around

Let's start with a moving your turtle around the screen. There are a few commands you should know:

* `turtle.forward()` moves the turtle forward.
* `turtle.right()` turns the turtle to its right.
* `turtle.left()` turns the turtle to its left.
* `turtle.backwards()` moves the turtle backward.

With each command, you need to give Python an integer that tells you how much you want to move the turtle. With right and left, Python will turn the turtle that many degress. With backwards and forwards, Python will move the turtle that many pixels.

Let's move our turtle around! In the same shell that you started your turtle from, enter the following commands:

[source,python]
----
>>> turtle.right(15)
>>> turtle.forward(150)
----

You should see something like this on your screen:

[[turtlemove]]
.It moved!
image::images/turtlemove.png["The turtle has moved down and to the right, drawing a line behind it."]

Wherever the turtle moves, it draws a line behind it. You can change the color of the turtle (and the line), by using `color()`. Try this in your shell:

[source,python]
----
>>> turtle.color("red")
>>> turtle.forward(50)
----

Your line has grown longer, but now, part of it is red! 

[NOTE]
====
Want more colors? There's a complete list in Appendix TODO
====

=== Try this!
